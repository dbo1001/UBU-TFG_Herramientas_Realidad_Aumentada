\apendice{Documentación técnica de programación}

\section{Introducción}
En este apartado se explicarán los pasos para la instalación y ejecución de las herramientas con las que se deberá trabajar.
%\newpage
\section{Estructura de directorios}
En este apartado se procederá a dar una breve explicación de la estructura que ha seguido los directorios del proyecto.\\
\newpage
\dirtree{%
.1 /.
.2 \textbf{Documentación/} Documentación: memoria y los anexos.
.3 \textbf{img}/ Imágenes de la documentación.
.3 \textbf{text}/ Archivos latex de la documentación.
.3 \textbf{anexos.Pdf}  Anexos.
.3 \textbf{memoria.Pdf} Memoria.
.2 \textbf{Ejemplo/} Ejemplo de realidad aumentada.
.3 \textbf{Plant-test/} Ejemplo de realidad aumentada.
.4 \textbf{Asset/} Assets del proyecto.
.5 \textbf{Animation/} Animaciones usadas.
.5 \textbf{AssetsOfStore/} Assets gratuitos descargados de la tienda de unity.
.5 \textbf{Codigo/} Scripts usados.
.5 \textbf{Material/} Materiales usados para componenetes del proyecto.
.5 \textbf{Scenes/} Escenas de Unity.
.4 \textbf{Library/} Librerías usadas en el proyecto.
.3 \textbf{APK/} APK de la aplicación.
}



\section{Manual del programador}

\subsection{Unity}\label{sub:Unity}

\subsubsection{Instalación}

Para Instalar el motor Unity es necesario descargar \textbf{Unity Hub}:\\ \url{https://store.unity.com/es/download-nuo}

Unity Hub se trata de un launcher desde el que se pueden descargar Unity, con la posibilidad de tener distintas versiones al mismo tiempo, pudiendo así escoger la que mejor se acomode a las necesidades del usuario para cada proyecto. También ofrece una serie de tutoriales para iniciarse en el desarrollo de Unity. Por último ofrece un listado de los proyectos que trabaja el usuario, así como a que versión pertenecen, pudiendo escoger con que versión de Unity desean ejecutarlos.

En la pestaña de \textbf{installs}, pulsando el botón <<\textbf{Add}>>, saldrá una ventana donde poder escoger la versión ha descargar( ver~\ref{fig:Anexos/unity01}), al pasar el siguiente paso se escogerán los módulos complementarios para Unity, por el momento sería necesario el modulo de Android, que permitirá construir los proyectos en una aplicación Android, importante desplegar las opciones del módulo y seleccionar ambas tal como se ve en la imagen~\ref{fig:Anexos/unity02}, pues para la compilación de una aplicación es estrictamente necesario el APK de Android.

\imagen{Anexos/unity01}{Paso 1: Seleccionar la versión de Unity }

\imagen{Anexos/unity02}{Paso 2: Seleccionar}

\label{sub:Confi}\subsubsection{Configuración }

Una vez terminada la instalación ya es posible comenzar a crear proyectos. 

El proceso para crear un proyecto es, desde Unity Hub, en la pestaña \textbf{Projects} seleccionar el botón <<\textbf{NEW}>>, se desplegará una ventana en la que escoger el tipo de proyecto a crear (2D, 3D, etc), el nombre y la ruta en la que se guardará. En el caso desarrollado, se trata de un proyecto 3D.

Una vez se ha generado el entorno, el siguiente paso será hacer las configuraciones iniciales. En primer lugar se deberá cambiar la plataforma de compilación del proyecto de Windows a Android, este paso permitirá que al construir el ejecutable de la aplicación, este sea compatible con la plataforma seleccionada. 
Para realizar el cambio ir a la pestaña \textbf{File, Build Settings}, en esta ventana se verá las diferentes plataformas para las que se puede diseñar el proyecto. De forma predeterminada al crear un nuevo proyecto se encuentra seleccionado ``Windows``, se deberá cambiar a ``Android`` dado que el proyecto esta pensado en un principio para dispositivos Android.

Para poder descargar y usar Assets desde la tienda de Unity es necesario tener una cuenta de usuario.

Dado que en el ejemplo realizado en Unity y se utiliza Vuforia como herramienta de realidad aumentada, es necesario añadir dicha herramienta al proyecto de Unity en el que se trabajará. Para ello, se deberá acudir a la página de \href{https://developer.vuforia.com/downloads/sdk}{developer de Vuforia}, desde donde es posible descargar la última versión una vez registrados. Para instalarlo en el proyecto se deberá importar el fichero descargado, este paso se puede realizar fácilmente unicamente arrastrando el fichero a la ventana del proyecto, o ejecutando el fichero descargado con el proyecto abierto.

Aparte del método descrito hay otras posibilidades para instalar Vuforia, aunque recomiendo el anterior método pues al tratarse de su página oficial tiene mayor seguimiento.

Algunas de las otras posibilidades son:
\begin{itemize}
	\item Desde la pestaña de la \textbf{tienda de Assets} de Unity, buscar Vuforia. Entre los resultados se encontrarán distintos Assets ofrecidos por la compañía de Vuforia. Nos interesará el llamado ``\textbf{Vuforia Engine}``, al descargar y importar este asset en el proyecto, siguiendo los sencillos pasos de la tienda, se instalará Vuforia en el proyecto.
	Otra posibilidad, podría ser descargar ``\textbf{Vuforia Core Samples}``. Este Asset de Vuforia se diferencia, en que aparte del engine de Vuforia, incluye varios ejemplos ya construidos, de algunas de sus diferentes funcionalidades, estos ejemplos añadidos se pueden borrar del proyecto en caso de que no nos interesen. En mi caso instale por error ``Vuforia Core Samples``.
	
	\item Este método que se va describir a continuación, es posible que no se encuentre disponible en las ultimas versiones de Unity, específicamente desde la versión 2019.3 que es la versión en la que Unity ya no tiene Vuforia de forma nativa. Si la versión con la que trabaja de Unity es inferior a la 2019.3 podrá seguir los siguientes pasos. Desde la pestaña de \textbf{Edit-Project Settings}, en el apartado \textbf{Player-XR Settings}, nos encontraremos con varias herramientas incluidas por defecto en Unity, marcamos el check de Vuforia y se incluirá automáticamente en nuestro proyecto. Se pueden ver los pasos descritos en la imágenes~\ref{fig:Anexos/VuforiaPlayer01} y \ref{fig:Anexos/VuforiaPlayer02}.
	
\end{itemize}

\imagenPeque{Anexos/VuforiaPlayer01}{Instalación Vuforia en Unity paso 1.}

\imagenPequeDos{Anexos/VuforiaPlayer02}{Instalación Vuforia en Unity paso 2.}

\subsubsection{Construcción proyecto primeros pasos}

Para la construcción de un proyecto de realidad aumentada con Vuforia, los dos primeros elementos que se deberán añadir son la \textbf{ARcamara} y el \textbf{Target} ( Para la aplicación propuesta se usará un MultiTarget). La AR Camera se trata de la cámara diseñada por Vuforia para el uso de realidad aumentada, y el Multitarget se trata del elemento en el se establecerá que targets se reconocerán y sobre donde se construirán los objetos de realidad aumentada.
El proyecto creado por Unity lleva por defecto una cámara normal, como para nuestra aplicación no la utilizaremos la podemos borrar.
Para añadir la ARcamara hacemos click derecho, Vuforia Engine, y escogemos AR Camera (ver imagen~\ref{fig:Anexos/vuforiaCameraAR}). 

Se deberá configurar la AR Camera añadiendo la \textbf{license key} que nos proporciona Vuforia en su página \href{https://developer.vuforia.com/license-manager}{developer de Vuforia} en el apartado Develop. Para añadir la clave, debemos seleccionar la cámara, y en el inspector pulsar ``\textbf{Open Vuforia Engine configuration}``. Una vez abierta la configuración de Vuforia, podremos añadir en el apartado ``\textbf{App License key}`` (ver imagen \ref{fig:Anexos/vuforiaLicense}). 

\imagenPeque{Anexos/vuforiaCameraAR}{Pasos para añadir la cámara AR de Vuforia.}

\imagen{Anexos/vuforiaLicense}{Pasos para incluir la license key de Vuforia.}

Para añadir el multiTarget hay que seguir un proceso similar, como se puede ver en la imagen~\ref{fig:Anexos/vuforiaCameraAR} también esta la opción de añadir un MultiTarget (Multi image). Pero si añadimos un target ahora mismo, de ese modo, este no tendra ninguna imagen asociada por lo que no podra ser reconocido. Se pueden añadir imagenes a los target desde Unity, pero es mas recomendable hacerlo desde su propia Web, ya que nos indicara también la calidad de la imagen deseada para ser un target. Para ello en el portal de Vuforia ya registrados deberemos ir al apartado ``Develop``, y en este seleccionar ``Target Manger``. Seleccionamos ``Add Database, Type Device``. En la siguiente ventana escogemos ``Add Target`` y configuramos el target. Una vez configurado le podremos descargar y importar en el proyecto. De esta manera el multitarget ya está configurado con el Mergecube. Click derecho, Vuforia Engine, y escogemos multiTarget, podremos apreciar que el cubo tiene las imágenes que habíamos configurado. Hay que asegurarse de que el cubo este en el campo visual de la cámara en la escena del proyecto, de lo contrario no se podrá reconocer al ejecutarse. Será en este elemento al que tendremos que asociar los modelos que queremos que se muestren en el Mergecube al enfocar nuestro dispositivo al MergeCube.


Con estos dos elementos, el esqueleto principal de la aplicación para poder reconocer el MergeCube ya esta construido. Ahora si se deseamos incorporar un modelo 3D que se muestre cuando se reconozca el MergeCube. Deberemos asociar el modelo 3D como hijo del multitarget. Hay que asegurarse de que estén situados la misma posición en la escena, pues lo elementos que se asocien al multitarget aparecer en relación a la su posición en la escena.


\subsection{Ejemplo Unity}
En esta sección explicare algunos de los pasos que segui en el resto de la construcción de la aplicación.

Dado que queremos representar el crecimiento de un planta debo buscar algún modelo 3D de plantas para Unity, se pueden buscar en la tienda de Assest de Unity o alguna plataforma Web. Una vez se seleccionado un modelo que nos interese, se importa en el proyecto, y cuando se añada en la escena se deberá incluir como hijo del MergeCube. El tema de incluir un elemento como hijo de otro es objetivo de mantener un orden y que si realizamos por ejemplo un cambio de posición o de escala en el padre, ese cambio también afectará al hijo, de lo contrarío al realizar uno de esos ajustes habría que repetirlo para el otro modelo o de lo contrario se desajustarían, al incluirlo como hijo del MergeCube esto también permitira que al ser detectado se muestre el modelo.

Para representar el crecimiento se representara el movimiento de regar la planta echando agua sobre la planta. Para representar esto buscamos un modelo de una regadera, una vez incluido, le podrá como hijo de la ARCamera. Al hacer esto permitirá que al mover el teléfono, el modelo seguirá el mismo movimiento.
Al realizarlo de esta manera hay que prestar atención en que coordenada se coloca, es necesario colocarlo ha cierta distancia de la cámara para que se aprecie cierta distancia, esto se puede ir probando posiciones hasta dar con una que nos parezca correcta.
Para añadir el efecto de agua, he usado efectos de partículas de Unity. En la configuración de las partículas de agua, hay que activar el modificador de gravedad dándole un valor de 10, y el tipo de espacio simulado en World, el número máximo de partículas también le he aumentado hasta 10000 y cambiar el color de la partícula por un azul. Ahora el problema está en que las partículas siempre caen en la misma inclinación sin importar la posición del dispositivo, para conseguir usar el giroscopio de dispositivo he creado un Script que detecta el giroscopio y ajusta el eje de gravedad según los movimientos del dispositivo. Este proceso fue algo tedioso debido al tener que estar compilando y pasando la aplicación al dispositivo para probar que funcionaba correctamente.

Para detectar y contar el número de partículas que colisionan con la planta, he creado otro scipt usando \href{https://docs.unity3d.com/ScriptReference/Collider.OnCollisionEnter.html}{OnCollisionEnter}. Se suma cada colisión y va actualizando una barra de progreso en la interfaz.

Una vez que se detecta el progreso del agua, las fases de las plantas se implementaron de una manera sencilla. Cuando se detecta el tope de agua para una fase, se cambia el modelo de la planta a uno mas grande, y así sucesivamente hasta llegar a la ultima fase.

Un problema que tiene el realizar una aplicación para móviles, es que cada vez que se quiera hacer una prueba en el dispositivo es necesario compilar al apk. Este proceso para hacer pruebas puntales no tiene un gran impacto en cuanto esfuerzo y tiempo invertido, pero si es necesario hacer muchas pruebas, por que por ejemplo hay un bug especifico que unicamente ocurre en el dispositivo móvil, el impacto en tiempo invertido en compilar será considerable.


Para la implementación de las funcionalidades de Device Tracker y crear target personalizados, me basare en el material que ofrece Vuforia en su ejemplo\footnote{\url{https://assetstore.unity.com/packages/templates/packs/vuforia-core-samples-99026}} utilizando de base sus mismos scripts.

Para la captura de un target personalizado, hay que crear en la interfaz una señal que indique la calidad del objetivo que se desea transformar en un target.
Esto puede realizarse mediante una representación de tres colores, como un semáforo.
Después hay que añadir en el proyecto un ImagenTarget de Vuforia() y configurarlo definiendo el tipo de imagen target que es como User Defined. El ImagenTarget será la referencia de Unity para colocar el modelo 3D por ello es muy importante asegurase de que el ImagenTarget está situado en el campo de visión de la ARcamera, o de lo contrario será imposible reconocerle. 
Seguido hay que añadir CameraImageBuilder que es el encargado de construir el target temporal. 
Ahora el paso ha seguir es de asignar a los componentes creados sus respectivos scripts que contralan las funciones. 

Durante este proceso en mi primer intento, Unity tuvo algún fallo y corrompió el proyecto. Haciendo imposible asociar ningún script y ademas los que estaban asociados anteriormente también fallaban impidiendo su uso. Para solucionar el bug probé dos posibles soluciones: borrar los metadatos y reimportar todo el proyecto, por desgracia ninguno funciono por lo que tuve que volver a una copia de seguridad.


Para implementar el Device tracker hay que crear un botón para poder activarlo y desactivarlo. Una vez creado el botón, simplemente hay que asociar el correspondiente script de DeviceTracker a las acciones del botón al ser pulsado.


Para mejorar la interfaz, estoy añadiendo efectos de movimiento en algunos de los menús con las animaciones de Unity , cambiando fonts y skins. Por ejemplo el menú que se despliega al mostrar las herramientas antes simplemente aparecía y desaparecía, ahora he añadido la animación para que se despliegue desde el marco derecho de la pantalla.


Hasta este momento en la aplicación únicamente se había trabajado con un único modelo de una planta, ahora incorporare otro dos modelos.  La complicación de esto se encuentra en el proceso por el cual el usuario escoge un modelo. Tenemos creado en el menú una lista de las plantas seleccionables, al seleccionar la función asociada a al botón, hará que al cargar la escena con las plantas, la función del script controlador active únicamente la planta seleccionada.



\subsection{Desarrollo en CoSpaces}
Dado que teniamos el MergeCube, se decido también hacer pruebas en CoSpaces, ya que cuenta soporte oficial para el MergeCube. Otra de las razones era comprobar su uso para la docencia.

Para el desarrollo en CoSpace empecé creando un nuevo proyecto. Dado que el ejemplo deberá funcionarán con el MergeCube, en las primeras opciones que nos da al crear el proyecto se podrá incluir.
Una vez creado el proyecto con el plug de Mergecube, tendremos un espacio de trabajo vació con el cubo de Mergecube en el centro. Esto se trata de una manera sencilla de poder crear un espacio de trabajo, por lo que no sería necesario de un alto nivel de conocimientos.

Para añadir los elementos deseados en el entorno, cuenta con un sencillo panel desde el que seleccionar modelos que ofrece CoSpace, o la posibilidad de importar modelos 3D de una fuente externa, mediante un buscador en Google Poly o mediante una subida de archivos. CoSpaces es compatible con las extensiones obj, mtl, fbx, zip de modelos, y jpg, png, gif, svg, bmp de imágenes.

En cuanto a la manipulación de los modelos, se trata de una manipulación muy simple y rápida de aprender, da la posibilidad de mover, rotar y escalar el modelo . El problema de esta manipulación es al ser tan simple, no permite movimientos tan precisos, por ejemplo no permite mover objetos en diagonal. Para casos en los que se requiera más precisión habría que usar lo movimientos introduciendo las coordenadas exactas.

Otro de los aspectos de la edición de los modelos es el cambio de colores y textura. No a todos los modelos se les puede cambiar la textura a tu gusto, el color en cambio sí. Con los modelos importados hay más problemas a la hora de personalizar textura o color, pues si el modelo tiene diferentes capas, no es capaz de separarlas y cambiará todas de ese color al mismo tiempo. 

En algunos modelos predefinidos es posible escoger y activar animaciones, o diferentes estados para ese modelo. Por ejemplo en un modelo de un coche se puede escoger si tiene algunas puertas abiertas o no. La parte negativa es que no puedes definir tus propios estados o animaciones, por lo que unicamente es posible escoger entre las opciones que esos modelos predefinidos tengan. En todos los modelos es posible añadir un bocadillo para añadir un dialogo. También es posible añadir en todos los modelos ciertas físicas, pudiendo ajustando la masa del objeto, seleccionar si será un objeto estático, y alguna opción más, tal vez no es tan completo como otros software pero cumple.

También cuenta con programación, con ella es posible establecer diferentes eventos, cambios de escala, posición o establecer algunas normas para un juego entre muchas más posibilidades. CoSpaces ofrece dos tipos de programación, por bloques y programación en TypeScript:
\begin{itemize}
	\item La programación por bloques es una buena forma de iniciación, en especial para los más jóvenes, pues es bastante rápido aprender como funciona. La pega de la programación por bloques es que está limitado a los bloques que nos ofrece, es posible crear tus propios bloques pero no tiene suficiente "diseño" para ajustarse a tantas opciones como una programación por script. 
	\item La otra posibilidad para programar que ofrece CoSpaces, se trata de elaborar script de en TypeScript. Si se tiene experiencia en programación en otros lenguajes, no resulta difícil acostumbrarse. La parte negativa que tiene esta opción es que la API de CoSpaces, no es tan completa como cabria esperar, sumado a que su "guía de usuario" podría estar mejor.
\end{itemize}
 

CoSpaces también da la posibilidad de crear espacios de trabajo para alumnos, en estos espacios se puede asignar tareas a los alumnos.

Finalmente se desarrollo un ejemplo en el que se intentaba realizar lo mismo que se estaba desarrollando en Unity. En el siguiente vídeo podemos ver dicho ejemplo: \url{https://www.youtube.com/watch?v=wG1fMxFDHzM}

\section{Compilación, instalación y ejecución del proyecto}
Antes de proceder es importante tener previamente Unity instalado~\ref{sub:Unity}.


Los pasos consisten en descargar del repositorio la carpeta UBU AR Aplicación. Una vez descargado y situado en la ruta deseada para trabajar, se deberá abrir Unity-Hub. Desde la venta de Unity-hub tenemos las opciones de nuevo proyecto o \textbf{añadir}, en este caso nos interesa añadir uno ya existente, al seleccionarlo nos mostrará una ventana para seleccionar la ruta en la que hemos guardado el proyecto descargado. Una vez seleccionado la ruta, se nos añadirá en la lista de proyectos de Unity-Hub, desde donde si se ha añadido correctamente le podremos iniciar normalmente.




\section{Pruebas del sistema}
Las pruebas realizadas a la aplicación, se han realizado mediante pruebas de forma manual directamente en el dispositivo móvil. Algunas pruebas también se han hecho en un emulador de Android, aunque desgraciadamente no terminaban de ser 100\% fiables debido a comportamientos inexactos a un dispositivo, por lo que las pruebas se repetían en el dispositivo una vez pasadas en el emulador. 

Una de las primeras pruebas ha realizar es el de la instalación en el dispositivo, para comprobar que el APK se ha realizado correctamente y es funcional. 

\subsection{Pruebas Reescalado}
Para comprobar el reescalado de la interfaz de la aplicación, se ha probado en distintos dispositivos, varios smartphone, y una tablet~\ref{tabla:dispositivos}. En cada pantalla de la interfaz, se comprueba que cada elemento es visible independientemente de el dispositivo.

En la interfaz del modo juego, al realizar pruebas en dispositivos que tienen en la pantalla el popular notch (cámara frontal que sobresale como una muesca en la pantalla) se apreció que en la interfaz no se tenía en cuenta el notch, por lo que este tapaba una parte de la barra de progreso. Para corregirlo se ha bajado la barra de progreso.

Junto las pruebas de reescalado se hacían pruebas de navegación entre el menú, comprobando que cada botón redirige a su pantalla correspondiente al mismo tiempo que reescala correctamente.

\tablaSmall{Dispositivo en los que se han realizado pruebas}{l c c }{dispositivos}{\multicolumn{1}{l}{Modelo}& Versión& tipo\\}{
	Xiaomi Redmi Note 5& Android 8.1 & Smartphone\\
	Xiaomi Mi A3& Android 10& Smartphone \\
	Huawei MediaPad M3 Lite 10& Android 7.0&  Tablet\\
}

\subsection{Pruebas detección Mergecube}
En la detección del cubo como target, la gran mayoría de las pruebas iniciales se han podido hacer desde el entorno de Unity con una webcam. Las pruebas que se realizaban con la webcam debido a la calidad de imagen no siempre eran todo lo buenas que se esperaba, pero si podían demostrar que la detección funcionaba.

Pero para dar mayor fiabilidad a las pruebas, se han probado también en el dispositivo. Consistían en comprobar que el Mergecube era reconocido correctamente, y que cuando es detectado, el modelo 3D asociado se puede visualizar adecuadamente.

Una de las primeras pruebas que se realizó, fue mover el Mergecube para comprobar que el modelo 3D se movía con los movimientos correspondientes. En el siguiente vídeo subido a Youtube, se puede observar esa prueba con un modelo que no se ha sido utilizado en la aplicación: \url{https://www.youtube.com/watch?v=SaZeSrDMNEE}.

Otra de las pruebas trata de enfocar cada cara del cubo, demostrando que en cualquier cara es reconocido, para complementar se han hecho pruebas tapando un porcentaje de la cara del cubo. 

En el siguiente enlace se pueden ver estas pruebas:\\ \url{https://www.youtube.com/watch?v=dFsnTGja6-I}.

\subsection{Pruebas autoenfoque}
La detección falla cuando se acerca bastante la cámara al cubo, debido a que el autoenfoque esta desactivado. Pero investigando, encontré que Vuforia sí posee funciones para controlar el autoenfoque. Al activarse permite que el reconocimiento del cubo mejore incluso en distancias mas cortas.

En este vídeo en la primera parte la cámara tiene el autoenfoque desactivado, mientras que en la segunda esta activado:\\ \url{https://www.youtube.com/watch?v=FsTertkK1gY}.



\subsection{Pruebas luminosidad}
También se ha probado la detección con diferentes entornos de luminosidad, en el caso de los extremos de luminosidad (poca y mucha), la detección del Mergecube se dificulta. Por ejemplo en los casos de demasiada iluminación, provoca que el contraste de iluminación impida reconocer el Mergecube. 
\url{https://www.youtube.com/watch?v=0kfcTpOKaV8}.

\subsection{Pruebas Device Tracking}
Otra de las pruebas es respecto a la implementación del Device Tracking. Para probar el funcionamiento del device tracking, el el vídeo se comprueba como al no tenerlo activado, en el momento que el Mergecube sale del campo visual de la cámara se pierde el modelo 3D cargado, y cuando volvemos a apuntar al cubo hay que esperar a que vuelva a reconocerlo. En cambio cuando el device tracking está activado, al volver enfocar el cubo se aprecia que el modelo sigue ahí:\\~\url{https://www.youtube.com/watch?v=5szopM7FkAQ}.

Del mismo modo si tenemos un modelo 3D mas grande que el Mergecube al apuntar un extremo fuera del Mergecube no desaparecerá. Vídeo:\\~\url{https://www.youtube.com/watch?v=zBC3y8zizVI}.

\subsection{Pruebas Captura Target}
Para probar las capturas de un target personalizadas, se han hecho pruebas con diversos objetivos. También se ha puesto a prueba la posibilidad de tener múltiples marcadores al mismo tiempo. En este vídeo se intenta hacer capturas de target sobre un poster, apuntado ha diversos objetivos: \url{https://www.youtube.com/watch?v=k_bbJS2Hb1w}	


\subsection{Prueba Sensor Giroscopio}
Para la comprobación del uso del sensor del giroscopio, seleccionamos la herramienta de la regadera, una vez seleccionada empieza a soltar partículas de agua, al girar el dispositivo en diferentes ángulos las partículas se moverán para dar la sensación de que siempre están cayendo hacia el suelo. 

En el primer vídeo vemos una de las primeras pruebas:\\ \url{https://www.youtube.com/watch?v=O9vR6dptWag}.

 El segundo es del estado actual de la aplicación:\\ \url{https://www.youtube.com/watch?v=ZpLFIQjsxmY}

\subsection{Pruebas Permisos}
Dado que la aplicación necesita algunos permisos para poder acceder a algunas características del dispositivo, se han hecho las pruebas de dichos permisos. En el siguiente vídeo, al acceder an el modo jugable, solicita permisos para poder guardar archivos en el dispositivo: \url{https://www.youtube.com/watch?v=QWSm2oUMCtA}. Esto se debe a que para guardar una captura de pantalla es necesario que el sistema tenga permiso para guardarla en una ubicación distinta de la raíz.




Por último destacar que Unity posee cualidades para realizar algunas pruebas unitarias de forma automática, pero no ha sido posible dada la limitación del tiempo.